---
layout:     article

title:      "C++ Primer 读书笔记02"

subtitle:   ""

date:       2020-9-11

author:     "thewangcj"

header-img: ""

catalog: false

tags:
    - 读书笔记
---

> “C++ Primer”

------

<!--more-->

#### ```this```

```this```总是指向“这个”对象，所以```this```是一个常量指针

常量对象，以及常量对象的引用或指针都只能调用常量成员函数

原因：虽然```this```是隐式的，但仍然遵守初始化规则，所以不能把```this```绑定到一个常量对象上，所以这就是不能在一个常量对象上调用普通成员函数的原因

#### ```const```成员函数

```c++
std::string isbn() const {return this->bookNO;}
```

上例中```const```的作用是修改隐式```this```指针的类型，表示```this```是一个指向常量的指针

#### 访问控制

使用 ```class```和```struct```定义类唯一的区别就是默认的访问权限

#### 友元

* 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限

* 友元的声明仅仅指定了访问的权限，而不是通常意义上的函数声明，需在友元声明外再专门对函数进行一次声明

* 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员

#### 可变数据成员

一个可变数据成员```mutable```永远不会是```const```，即使它是```const```对象的成员，因此，一个```const```成员函数可以改变一个可变成员的值

#### 构造函数初始值列表

* 如果没有在构造函数的初始值列表中显式的初始化成员，则该成员将在构造函数体之前执行默认初始化，也就是说构造函数的初始值列表中是定义并且初始化，而在构造函数中赋值的话是先执行默认初始化然后再赋值，影响效率
* 如果成员是```const```、引用或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值
* 建议使用构造函数初始值列表

#### 委托构造函数

一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把自己的一些（或者全部）职责委托给其他构造函数

```c++
class Sales_data {
  public:
  // 非委托构造函数使用对应的实参初始化成员
  Sales_data(const std::string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n) {}
  // 其余构造函数全都委托给另一个构造函数
  Sales_data() : Sales_data("", 0, 0) {}
  Sales_data(const std::string &s) : Sales_data(s, 0, 0) {}
  Sales_data(std::istream& is):Sales_data() {read(is, *this)}
}
```

#### 默认构造函数

##### 默认初始化

1. 在块作用域不使用任何初始值定义一个非静态变量或者数组时
2. 当一个类本身含有类类型成员且使用合成的默认构造函数时
3. 当类类型的成员没有在构造函数初始值列表中显示的初始化时

##### 值初始化

1. 当数组初始化的过程中如果我们踢动的初始值数量少于数组的大小时
2. 当不使用初始值定义一个局部静态变量时
3. 当书写形如 ```T()``` 的表达式显式的请求初始化时

#### 隐式的类类型转换

```c++
string null_book = "888";
// 接受 string 的构造函数自动创建了一个临时的 Sales_data 对象，combine 的参数是一个常量引用所以可以传递一个临时变量
item.combine(null_book);
```

```explicit```：通过将构造函数声明为```explicit```加以阻止隐式转化，由于需要多个参数的构造函数无法执行隐式转换，所以```explicit```只对含有一个实参的构造函数有效

*注意*：```explicit```只允许出现在类内的构造函数声明处

#### 类的静态成员

* 类的静态成员存在于任何对象之外，对象中不包含任何与静态成员有关的数据
* 静态成员函数也不与任何对象绑定在一起，它们不包含```this```指针，因此，静态成员函数不能声明成```const```的，而且也不能在```static```函数体内使用```this```指针
* 在类的外部定义静态成员时，不能重复```static```关键字，该关键字只能出现在类内部的声明语句
* 可以使用静态成员作为默认实参
* 静态数据成员可以是不完全类型，如可以是它所属的类类型

