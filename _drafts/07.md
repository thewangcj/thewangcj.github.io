---
layout:     article

title:      "C++ Primer 读书笔记07"

subtitle:   ""

date:       2020-11-12

author:     "thewangcj"

header-img: ""

catalog: false

tags:
    - 读书笔记

---

> “C++ Primer”

------

<!--more-->

#### 继承

##### protected

基类希望它的派生类有权访问该成员，同时禁止其他用户访问

- 与 private 一样，protected 成员对类的用户是不可见的；
- 与 public 一样，protected 成员对派生类的成员和友元是可见的；
- 派生类的成员和友元只能通过派生对象访问基类的 protected 成员。派生类不能访问独立的基类对象的 protected 成员，如：

```c++
class Base {
protected:
    int prot_mem;
};
class Sneaky : public Base {
    friend void clobber(Sneaky &); //可以访问 Sneaky::prot_mem
    friend void clobber(Base &); //不能访问 Base::prot_mem
    int j;
};
void clobber(Sneaky &s) { s.j = s.prot_mem = 0; }
//错误：clobber 不能访问 Base 中的 protected 成员
void clobber(Base &b) { s.prot_mem = 0; }
```



##### 派生类构造函数

对象的基类部分与派生类的数据成员一起在构造函数的初始化阶段进行初始化。与初始化成员一样，派生类构造函数使用构造初始值列表来传递参数给基类构造函数。如：

```c++
Bulk_quote(const std::string &book, double p, std::size_t qty, double disc):
    Quote(book, p), min_qty(qty), discount(disc) { }
```

##### 静态成员

如果在基类中定义了静态成员，那么整个继承层级中只有此成员的唯一定义。不管从一个基类中派生了多少类，每个静态成员只存在一份实例。

##### final

`C++11`提供的一种防止继承发生的方式，即在类名后加一个关键字`final`

#### 动态绑定

##### 静态类型与动态类型

表达式的静态类型在编译时就是已知的，它是变量声明时的类型或者表达式的结果类型。

动态类型是变量或表达式所表示的在内存中的真正对象的类型，这个类型必须到运行时才能知道

##### 虚函数（virtual function）

基类将希望派生类定义自己的版本的函数为`virtual`的，派生类必须在其内部对所有重新定义的虚函数进行声明

基类通常应该定义虚析构函数，即便不做任何工作也是如此

`virtual`关键只出现在类体内的函数声明处，而不会被用于类体外的函数定义处。在基类中被定义为`virtual`的函数，其在派生类中隐式也是`virtual`的。

由于调用哪个版本是由实参的类型决定的，而实参类型只有在调用时才能知道。因而，动态绑定有时也被称为运行时绑定（run-time binding）。在`C++`中，动态绑定发生在虚函数通过基类的引用或指针调用时。

#### 抽象基类

##### 纯虚函数

通过在函数体的位置（即在声明语句的分号之前）写上`=0`就可以将一个函数说明为纯虚函数，其中`=0`只能出现在类内部的虚函数声明语句处。

##### 抽象基类

含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类（abstract base class），抽象基类负责定义接口，而后续的其他类可以覆盖该接口，我们不能直接创建一个抽象基类的对象。



































