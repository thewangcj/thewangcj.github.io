---
layout:     article

title:      "C++ Primer 读书笔记08"

subtitle:   ""

date:       2020-12-02

author:     "thewangcj"

header-img: ""

catalog: false

tags:
    - 读书笔记


---

> “C++ Primer”

------

<!--more-->

#### 函数模板

一个函数模板就是一个公式，用来生成针对特定类型的函数版本，如：

```c++
template <typename T>	// 类型参数必须使用关键字 class 或 typename
int compare(const T &v1, const T &v2)
{
    if (std::less<T>()(v1, v2)) return -1;
    if (std::less<T>()(v2, v1)) return 1;
    return 0;
}
```

##### 非类型模板参数

除了可以定义类型参数，还是可以定义带有非类型参数（nontype parameters）的模板。非类型参数表示一个值而不是类型。非类型参数通过使用特定类型名字而不是 class 或 typename 来指定。当模板被实例化时，非类型参数将被一个用户提供的值或者编译器推断的值替代。这些值*必须是*常量表达式（constant expressions），只有这样编译器才能在编译期间实例化模板。如：

```c++
template <unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    cout << N << std::endl;
    cout << M << std::endl;
    return strcmp(p1, p2);
}
compare("hi", "mom");  // 编译出 int compare(const char (&p1)[3], const char (&p2)[4]);
```

##### inline 和 constexpr 函数模板

inline 和 constexpr 放在模板参数列表之后，返回类型之前

```c++
template <typename T> inline T min(const T &, const T &);
```

##### 编写与类型无关的代码

编写泛型代码的原则：

1. 模板中的函数参数是`const`的引用
2. 函数体中的条件判断仅使用`<`比较运算

##### 模板编译

当编译器遇到一个模板定义时，它并不生成代码，只有实例化出模板的一个特定版本时，编译器才会生成代码，当我们使用（而不是定义）模板时，编译器才生成代码。

##### 模板和头文件

通常，当我们调用一个函数时，编译器只需要掌握函数的声明，类似的，当我们是用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现，因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。

模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，因此与非模板代码不同，*模板的头文件通常既包括声明也包括定义*。

#### 类模板

类模板（class template）是合成类的蓝本。与函数模板*不同的是*编译器不能推断出类模板的模板参数的类型。相反，使用类模板时必须提供额外的信息，这些信息将放在类模板名后的尖括号中。这些额外信息是模板实参列表（template arguments list），用于替换模板参数列表（template parameters list）。

##### 实例化类模板

类模板的每个实例都构成完全独立的类。类型 `Blob<string>` 和其它的`Blob`类型之间没有任何关系，亦没有任何特殊的访问权限。

##### 类模板的成员函数

类模板的每个实例都有其自己版本的成员函数，因此，类模板的成员函数具有和模板相同的模板参数，因此定义在类模板之外的成员函数就必须以关键字`template`开始，后接类模板参数列表，如：

```c++
template <typename T>
void Blob<T>::check(size_type i, const std::string &msg) const
{
    if (i >= data->size())
        throw std::out_of_range(msg);
}
// 构造函数
template <typename T>
Blob<T>::Blob(): data(std::make_shared<std::vector<T>()) { }
```

默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化，如果一个成员函数没有被使用，则它不会被实例化。

##### 类模板与友元

当类定义中包含友元声明时，类和友元可以相互不影响的时模板或者不是模板。类模板可以有非模板的友元，授权友元访问其所有的模板实例。如果友元自身是模板，授权友元的类控制访问权限是授给模板的所有实例还是给特定的实例。

##### 一对一友元

```c++
// 为了指定模板（类或函数）的特定实例，我们必须首先声明模板本身。模板的声明包括模板的模板参数列表。
template <typename> class BlobPtr;
template <typename> class Blob;
template <typename T>
bool operator==(const Blob<T>&, const Blob<T>&);

template <typename T> class Blob {
    // 每个 Blob 实例将访问权限授予用相同类型实例化的BlobPtr和相等运算符
    friend class BlobPtr<T>;	
    friend bool operator==<T>(const Blob<T>&, const Blob<T>&);
};
```



